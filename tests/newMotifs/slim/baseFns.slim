// General functions useful for quantitative population genetics - network models

function (void) setCfgParam(s$ name, ifls value) {
	// Automate defining constants for SLiMgui and slim command line
	
	if (!exists(name)) {
		defineConstant(name, value);
	}
}

// Get the locus cutoffs for each  
function (integer) getMolMutCutoffs(i$ molMuts) {
	molMutres = integer(molMuts); 
	molMutProp = 1/molMuts;

	for (i in seqLen(molMuts))
	{
		if (i == 0)
		{
			molMutres[i] = asInteger(ceil(molMutProp * nloci));
			next;
		}
		
		if (i == molMuts-1)
		{
			molMutres[i] = nloci;
			next;
		}
		
		molMutres[i] = asInteger(ceil(molMutProp * nloci)) + molMutres[i-1];
	}
	
	// if the first element has 0 loci, remove it
	if (molMutres[0] == 0) {
		molMutres = molMutres[1:(length(molMutres)-1)];
	}
	
	// Ensure we don't go over nloci
	molMutres[molMutres > nloci] = nloci; 
	
	// Remove extras in case we don't have all the molecular components (e.g. molMutProp has zeros) 
	molMutres = unique(molMutres);

	return molMutres;
}

function (void) assignQTLPositions(void) {
	// mol traits are in order: first molMutProp[0]% are alpha, next molMutProp[1]% are beta, then KZ, then KXZ
	// figure out the actual cutoffs 
	// molMuts == 7 for NAR and PAR
	molMuts = 7;

	// Set molMuts for different motifs
	if (modelType == "FFLC1" || modelType == "FFLI1") {
		molMuts = 9;
	}

	if (modelType == "FFBH") {
		molMuts = 11;
	}

	molMutres = getMolMutCutoffs(molMuts);
	defineConstant("molMutCutoffs", c(0, molMutres-1)); // convert to zero-indexed


	// Define locations of QTLs, deleterious loci, and neutral loci
	lengthvec = 0:(genomelength - 1);
	pos_QTL = sample(lengthvec, nloci);
	
	sim.setValue("pos_QTL", pos_QTL); //store these positions in a sim value
				
	posfile = paste(modelindex, asString(seed), nloci, pos_QTL, sep = ","); // Output information on where the QTLs are, and the recombination structure of the genome
	
	writeFile(outPositions, posfile, append = T);	
	
	// Define constants for plotting heterozygosity (diagnostics)
	if (printH == T) {
		sim.setValue("h2_history", NULL);
		defineConstant("pngPath", writeTempFile("plot_", ".png", ""));
		if (exists("slimgui"))
			slimgui.openDocument(pngPath);
	}

	// Set delta difference value
	sim.setValue("lastDist", 0.0);
	sim.setValue("lastw", 0.0);
	
	// Set initial sample rates for adaptive sampling
	if (adaptiveSampling == T) {
		sim.setValue("sRate", samplerate);
		sim.setValue("burnDelta", NULL);
		sim.setValue("curTime", 0);
	}	
	
	// Calculate and set mutation rates according to n loci so we have a consistent per-genome rate
	u_g = genomelength * mu;
	u_q = u_g / nloci;
	u_n = u_g / (genomelength - nloci);
	
	// return early if we have no QTLs: mutation rate is always mu
	if (length(pos_QTL) == 0) {
		return;
	}
	
	ends = findMutBreakpoints(pos_QTL);

	// determine what rates to use: starting with neutral or qtl depending on whether we have a QTL at pos 0
	if (sort(pos_QTL)[0] == 0) {
		rates = rep(c(u_q, u_n), length(ends));
	} else {
		rates = rep(c(u_n, u_q), length(ends));
	}
	
	// shorten to match ends length
	rates = rates[0:(length(ends)-1)];	
		
	// get a vector of values
	sim.chromosome.setMutationRate(rates, ends);

}

function (i) findMutBreakpoints(i pos) {
	// sort the list
	pos = sort(pos);
	
	// neutral breakpoints
	neuPos = pos - 1;
	
	// case where this is only 1 QTL
	if (length(pos) == 1) {
		result = c(neuPos[neuPos > -1], pos, genomelength-1);
		result = sort(unique(result));
		return result;
	}

	// collapse adjacent positions and exclude from breakpoints
	for (i in 1:(length(pos)-1)) {
		if (pos[i] == pos[i-1]+1) {
			pos[i-1] = -1;
			neuPos[i] = -1;
		}
	}
	pos = pos[pos > -1];
	neuPos = neuPos[neuPos > -1];

	// combine and add the last breakpoint (end of genome) if that isn't already sampled	
	pos = sort(c(pos, neuPos));
	if (pos[length(pos)-1] != genomelength - 1) {
		pos = c(pos, genomelength - 1);
	}
	
	// return sorted list
	return pos;		
}

function (io<MutationType>$) sampleMutTypeFromSite(i$ pos) {
	// Find the correct mutation type options for a given position and sample one
		
	// Load the actual positions of the QTLs
	pos_QTL = sim.getValue("pos_QTL");

	molMuts = 7;

	// Set molMuts for different motifs
	if (modelType == "FFLC1" || modelType == "FFLI1") {
		molMuts = 9;
	}

	if (modelType == "FFBH") {
		molMuts = 11;
	}
	
	molMutProp = 1/molMuts;


		// If we are an ubiquitin QTL we're in the first molMutProp[0]% of the nloci loci in pos_QTL - we will take the 
		// ceiling of that to be consistent
		// We can only sample neutral, deleterious, and aZ: m1, m2, m3
		// If we are at an enhancer site we're in the second molMutProp[1]% of the nloci loci in pos_QTL
		// We can only sample neutral, deleterious, and bZ: m1, m2, m4
		// If we are at KZ site we're in the third molMutProp[2]% of the nloci loci in pos_QTL
		// We can only sample neutral, deleterious, and KZ: m1, m2, m5
		// If we are at KXZ site we're in the fourth molMutProp[3]% of the nloci loci in pos_QTL
		// We can only sample neutral, deleterious, and KXZ: m1, m2, m6

		// exit early if we aren't a QTL: return m1
		if (!any(pos == pos_QTL)) {
			return sim.mutationTypes[0];
		}
		
		// Iterate through mutation types, sample relevant mutation

		for (i in 1:(length(molMutCutoffs)-1)) {
			if (any(pos == pos_QTL[asInteger(molMutCutoffs[i-1]):asInteger(molMutCutoffs[i])])) {
				return sample(sim.mutationTypes[c(0, i)], 1);
			}
		}		
		
		// if we somehow fail, stop the simulation
		stop(paste("sampleMutTypeFromSite: Failed to find mutation type for locus", pos));
	}
	
	// Additive/mult case: since we are additive/mult, we want to ignore mutTypes m4 onwards
	if (any(mut.position == pos_QTL)) {
		choice = sample(sim.mutationTypes[c(0,2)], 1);
	}
	else {
		choice = sample(sim.mutationTypes[0], 1);
	}
	
	if (isInteger(choice))
		return sim.mutationTypes[0];
	
	return choice;
}

function (void) calcPhenotype(o<Individual> inds, s$ calcMode) {
	// Calculate phenotypes for individuals based on their QTL effects - both segregating and substitutions
	// Handle additive first
	if (calcMode == "Add")
	{
	
		// Calculate phenotypes for individuals based on their QTL effects - both segregating and substitutions
		fixed = sim.substitutions;
		sizem3 = size(fixed[fixed.mutationType == m3]);
		fixedfx = sizem3 ? sum(fixed[fixed.mutationType == m3].selectionCoeff) else 0.0;
		
		for (ind in inds) {
			muts = ind.genomes.mutationsOfType(m3);			// Get only trait effects
			mutscount = size(muts);
			
			phenotype = (mutscount ? sum(muts.selectionCoeff) else 0.0);
			phenotype = phenotype + fixedfx; // add fixed effects
			if (calcMode == "Mult") {phenotype = exp(phenotype);}
			ind.phenotype = phenotype;
		}
		return;
	}

	// Handle ODEs
	inds.phenotype = sim.ODEIntegrate(inds, calcMode);
	return;

}

function (void) writeQuantileODEPar(o<Subpopulation> pop, [Nf quantiles = 0.5], [s$ type = "AUC"]) {
	// Write ODE parameter combinations - median value and IQR quantiles by default
	medianLine = paste(sim.cycle, asString(seed), modelindex, pop.getQuantileODEPar(quantiles, type), sep = ",");
	writeFile(outODEPars, medianLine, append = T);
}


function (void) calcFitnessGaussian(o<Individual> inds, fi$ optimum) {
	// Calculate fitness from phenotype. Make sure this is only called after CalcPhenotype()!
	phenotypes = inds.phenotype;
	dists = (phenotypes - optimum)^2;
	
	// Make sure that phenotype is never below 0
	dists[dists < 0] = 0.0;
	
	inds.fitnessScaling = exp(-(dists * width)); // Gaussian fitness function comes from Lande 1976: width is 1/2w^2
	// Make sure we never have all individuals with 0 fitness
	if (all(inds.fitnessScaling == 0.0)) { inds.fitnessScaling = 1e-6; }
	sim.setValue("fitness", inds.fitnessScaling);

}

function (integer) encodeCantorPairs(i x, i y) {
	return asInteger(0.5 * (x + y) * (x + y + 1) + y);
}

function (integer) decodeCantorPairs(i z) {
	w = floor((sqrt(8*z+1)-1) * 0.5);
	t = (w*w + w) * 0.5;
	
	y = asInteger(z - t);
	x = asInteger(w - y);
	return matrix(c(x, y), ncol = length(z), byrow = T);
}

// Return pairwise permutations of a vector
function (integer) perm(i x, [l$ includeDiag = F]) {
	// Create output matrix with all combinations
	y = rep(x, length(x));
	z = repEach(x, length(x));
	
	// Encode values with Cantor pair
	comb = encodeCantorPairs(y, z);	

	comboMatrix = matrix(comb, nrow = length(x));
	
	// Remove duplicates
	comboMatrix = comboMatrix[c(upperTri(comboMatrix, includeDiag))];
	
	// return matrix of x and y
	return decodeCantorPairs(comboMatrix); 
}

function (void) writeLDPairFile(o<Subpopulation> pop, s$ stat) {
	// Writes vector of pairwise LD comparisons sorted by frequency
	pos = sim.getValue("pos_QTL");
	comp = perm(pos);
	LDResult = sim.calcLDBetweenSitePairs(pop, comp[0,], comp[1,], statistic = stat, byFreq = T);
	LDLine = paste(sim.cycle, asString(seed), modelindex, LDResult, sep = ",");
	writeFile(outLD, LDLine, append = T);
}

function (void) writeLDComp(o<Subpopulation> pop, s$ statistic) {
	// Writes a pairwise LD matrix in compressed columnwise format
	// statistic: 	The statistic to calculate (r^2, D, D')
	LDResult = matrix(sim.calcLD(pop, statistic), nrow = genomelength, ncol = genomelength, byrow = T);
	LDCompressed = CompressLDMatrix(LDResult[c(upperTri(LDResult))]);
	writeFile(outLDComp_Pos, LDCompressed[0], append = T);
	writeFile(outLDComp_Val, LDCompressed[1], append = T);
}

// Writes the frequencies and shared frequencies of pairs of mutations A and B
function (void) writeSharedMutFreqs(o<Subpopulation>$ pop) {
	pos = unique(sim.getValue("pos_QTL"));
	comb = perm(pos);
	result = sim.sharedMutFreqs(pop, comb[0,], comb[1,]);

	n = length(result);

	// First two values for every pair in results are integers: we need to cast so writing
	// doesn't round and store an incorrect mutation id
	idA = asString(asInteger(result[seq(from = 0, to = n-1, by = 7)]));
	idB = asString(asInteger(result[seq(from = 1, to = n-1, by = 7)]));
	pA = asString(result[seq(from = 2, to = n-1, by = 7)]);
	pB = asString(result[seq(from = 3, to = n-1, by = 7)]);
	pab = asString(result[seq(from = 4, to = n-1, by = 7)]);
	paB = asString(result[seq(from = 5, to = n-1, by = 7)]);
	pAb = asString(result[seq(from = 6, to = n-1, by = 7)]);

	result2 = c(rbind(idA, idB, pA, pB, pab, paB, pAb));

	out = paste(sim.cycle, asString(inputSeed), inputModel, result2, sep = ",");
	writeFile(outSharedMutFreqs, out, append = T);
}

// Helper function to fix floating point rounding error
function (float) setSmallValToZero(float i) {
	return ifelse(i < 1e-10, 0.0, i);
}

// Write individual outputs: phenotypes for each individual in the population, and midparent value, 
// also alleles and moltraits
function (void) writeIndOutput(o<Subpopulation> pop) {
	inds = pop.sampleIndividuals(10);
	
}

function (void) savePopState(void) {
	sim.outputFull(outPopState, binary = T, pedigreeIDs = T);
}

function (void) writeHaploRel(o<Subpopulation>$ pop, i$ n) {
	inds = sample(pop.individuals, n);
}

function (void) writeHaplo(o<Subpopulation>$ pop, i$ n) {
	inds = pop.sampleIndividuals(n);
}

function (integer) colSums(integer mat) {
	result = integer(ncol(mat));
	for (i in seqLen(ncol(mat))) {
		result[i] = sum(mat[,i]);
	}
	return result;
}

// returns positions of loci with nonzero elements (i.e. >= 1 ind with a mutation)
function (integer) binaryMatrixLoci(i haplos, i$ nrow, i$ ncol) {
	colCutoffs = asInteger((nrow * 1:ncol) - 1);	
	colSums = integer(ncol);
	
	for (i in seqAlong(colCutoffs)) {
			colSums[i] = length(haplos[haplos <= colCutoffs[i]]);
	}
	
	colSums = colSums - c(0, colSums[0:(ncol-2)]);
	
	return colSums;
}

function (integer) StoreBinaryMatrix(integer mat) {
	if (any(mat != 0 & mat != 1)) {
		stop("StoreBinaryMatrix called with a non-binary matrix!");
	}
	n = length(mat);
	return (0:(n-1))[c(asLogical(mat))];
} 

// Compresses relatedness matrix list: input is the upper triangle of the relatedness matrix excluding diagonals
function (integer) CompressRelatednessList(float upperTri) {
	return which(upperTri != 0);
} 

// Get the relationship coefficients at a given position in the upper triangle
function (float) GetRelValues(float upperTri, integer pos) {
	return upperTri[pos];
}

// Compress LD matrix to columnwise indices and nonzero LD: input is upper triangle of the 
// pairwise LD matrix excluding diagonals 
function (string) CompressLDMatrix(float LDUpperTri) {
	indicesFile = paste(sim.cycle, asString(seed), modelindex, CompressRelatednessList(LDUpperTri), sep = ",");
	valuesFile = paste(sim.cycle, asString(seed), modelindex, LDUpperTri[c(LDUpperTri != 0)], sep = ",");

	return c(indicesFile, valuesFile);
}
