// set up a simple neutral simulation
initialize() {
	if (!exists("slimgui")) {
		defineConstant("seed", getSeed());
	}
	else {
		setSeed(asInteger(round(runif(1, 1, 2^62 - 1))));
		defineConstant("seed", getSeed());
		catn("Actual seed: " + asInteger(seed));
	}

	initializeSLiMModelType("WF");
	initializeTreeSeq(timeUnit = "generations");

	// Chromosome length
	setCfgParam("L", 9e6);

	// Mutation rate
	setCfgParam("mu", 1e-8);
	
	// Selection coefficient
	setCfgParam("s", 0.01);
	
	// Population size
	setCfgParam("N", 5000);
	
	// Number of adaptive mutations
	setCfgParam("n_s", 1);
	
	// Equilibrium check epsilon
	setCfgParam("eps", 1e-6);
	
	// A selected alleles region
	setCfgParam("Aregion", c(1e5, 2e5));	
	
	// B selected alleles region
	setCfgParam("Bregion", c(5e5, 6e5));
	
	// Input file path
	setCfgParam("inputFile", "/mnt/c/GitHub/SLiMTests/tests/coalBurnIn/test.trees");
		
	// Expected Heterozygosity at mutation-drift balance: H = theta / (1 + theta)
	defineConstant("theta", 4 * N * mu);
	defineConstant("H_e", theta / (1 + theta));
	
	// Model index
	setCfgParam("modelindex", 1);
	
	// Model identifier
	defineConstant("modelid", paste0(seed, "_", modelindex));
	
	defineConstant("outputPath", paste0("output_", modelid, ".vcf"));
	
	initializeMutationRate(mu);
	
	// m1 mutation type: neutral
	initializeMutationType("m1", 0.5, "f", 0.0);
	
	// m2 mutation type: beneficial in environment A, deleterious in environment B
	initializeMutationType("m2", 0.5, "f", s);
	m2.color = "red";
	
	// m3 mutation type: beneficial in environment B, deleterious in environment A
	initializeMutationType("m3", 0.5, "f", -s);
	m3.color = "green";
	
	
	// g1 genomic element type: uses m1 for all mutations
	initializeGenomicElementType("g1", m1, 1.0);
	
	// uniform chromosome of length 100 kb with uniform recombination
	initializeGenomicElement(g1, 0, L-1);
	initializeRecombinationRate(1e-8);	
}


function (void) setCfgParam(s$ name, ifls value) {
	// Automate defining constants for SLiMgui and slim command line
	if (!exists(name)) {
		defineConstant(name, value);
	}
}

mutationEffect(m2) {
	// For any odd populations, don't change the selection coeff 
	if (subpop.id % 2 != 0) {
		return effect;
	}
	// Flip the selection coeff sign
	if (homozygous) {
		return 1.0 - mut.selectionCoeff;
	}
	
	return 1.0 + mut.mutationType.dominanceCoeff * -mut.selectionCoeff;
}

mutationEffect(m3) {
	// For any even populations, don't change the selection coeff 
	if (subpop.id % 2 == 0) {
		return effect;
	}
	// Flip the selection coeff sign
	if (homozygous) {
		return 1.0 - mut.selectionCoeff;
	}
	
	return 1.0 + mut.mutationType.dominanceCoeff * -mut.selectionCoeff;
}


// create subpopulations
1 early() {

	// Read in population/mutation info
	sim.readFromPopulationFile(inputFile);
			
	// Setup simulation events
	community.rescheduleScriptBlock(s1, start = 1);
	community.rescheduleScriptBlock(s2, ticks = community.tick + 100 * N);
	community.rescheduleScriptBlock(s3, ticks = community.tick + 100 * N);
	
	defineConstant("pdfPath", writeTempFile("plot_", ".png", ""));
	sim.setValue("avg_he", NULL);
	if (exists("slimgui"))
	{
		slimgui.openDocument(pdfPath);
		sim.setValue("pdfOpened", F);
	}

}

s1 late() {
	// Check that the populations are close to equilibrium
	pop_avg = float(length(sim.subpopulations));
	
	for (i in seqAlong(sim.subpopulations)) {
		subpop = sim.subpopulations[i];
		inds = subpop.sampleIndividuals(10);
		avg = 0;	
		
		for (j in seqAlong(inds)) {
			avg = avg + (calcPairHeterozygosity(inds[j].haploidGenome1, inds[j].haploidGenome2) * 1 / length(inds));
		}
		
		pop_avg[i] = avg;
	}
	
	catn(paste("Tick:", community.tick, "Heterozygosity =", pop_avg)); 
	
	// If we're at equilibrium in all subpops, continue with the test
	if (all(abs(pop_avg - H_e) <= eps)) {
		community.rescheduleScriptBlock(s1, end = community.tick);
		community.rescheduleScriptBlock(s2, start = community.tick, end = community.tick);
		community.rescheduleScriptBlock(s3, ticks = community.tick + 10000);
		return;
	}
	
	if (community.tick % 10 == 0) {
		avg_he = mean(pop_avg);
		he_history = c(sim.getValue("avg_he"), avg_he);
		sim.setValue("avg_he", he_history);
		
		rstr = paste(c('{',
		'x <- (1:' + size(he_history) + ') * 10',
		'y <- c(' + paste(he_history, sep=", ") + ')',
		'png(file="' + pdfPath + '", width=4, height=4)',
		'par(mar=c(4.0, 4.0, 1.5, 1.5))',
		'plot(x=x, y=y, xlim=c(0, 50000), ylim=c(0, 500), type="l",',
			'xlab="Generation", ylab="Average heterozygosity", cex.axis=0.95,',
			'cex.lab=1.2, mgp=c(2.5, 0.7, 0), col="red", lwd=2,',
			'xaxp=c(0, 50000, 2))',
		'box()',
		'dev.off()',
		'}'), sep="\n");
		
		scriptPath = writeTempFile("plot_", ".R", rstr);
		system("/usr/local/bin/Rscript", args=scriptPath);
		deleteFile(scriptPath);
		
		if (!sim.getValue("pdfOpened"))
		{
			system("xdg-open " + pdfPath, wait=F);
			//sim.setValue("pdfOpened", T);
		}
	}
	
	
	if (community.tick == 10 * N) {
		stop("Failed to reach equilibrium heterozygosity...");
	}
}

s2 late() {
//late() {
	// Randomly sample mutations in the m2/m3 regions and turn them into m2/m3 mutations
	for (subpop in sim.subpopulations) {
		muts = subpop.genomes.mutations;
		isPopA = subpop.id % 2 == 0;
		region = isPopA ? Aregion else Bregion;
		putative = muts[muts.position >= region[0] & muts.position <= region[1]];
		
		// Sample n_s mutations per subpop
		adaptiveMut = sample(putative, n_s);
		
		// Update mutation info
		adaptiveMut.setMutationType(isPopA ? m2 else m3);
		adaptiveMut.setSelectionCoeff(s);
	}
}

s3 late() {
	// Output VCF
	c(p1.genomes, p2.genomes).outputVCF(outputPath);
	
}
