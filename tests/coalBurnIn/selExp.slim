// set up a simple neutral simulation
initialize() {
	if (!exists("slimgui")) {
		defineConstant("seed", getSeed());
	}
	else {
		setSeed(asInteger(round(runif(1, 1, 2^62 - 1))));
		defineConstant("seed", getSeed());
		catn("Actual seed: " + asInteger(seed));
	}

	initializeSLiMModelType("WF");
	initializeTreeSeq(timeUnit = "generations");

	// Chromosome length
	setCfgParam("L", 2e6);
	
	// Breakpoints for mutation and recombination rates
	setCfgParam("breaks", c(1000000, 1500000, 2000000-1));

	// Mutation rates
	setCfgParam("mu", c(1e-8, 1e-9, 1e-8));
		
	// Number of generations to apply selection before printing output 
	setCfgParam("selTime", 1000);
	
	// Recombination rates
	setCfgParam("r", c(5e-8, 0.5e-8, 5e-8));
	
	// Selection coefficient
	setCfgParam("s", 0.05);
	
	// Number of adaptive mutations
	setCfgParam("n_s", 3);
		
	// Equilibrium check epsilon: note this has to be chosen relative to population size
	// There will be a large amount of noise around the equilibrium in large populations
	setCfgParam("eps", 1e-5);
	
	// Number of regions per ecotype
	setCfgParam("n_r", 3);


	// Regions sampled using
	// leftboundary = sample(0:1999999, n_r * 2)
	//		1727750 1460268 1149215 883893 348079 1698376
	// rightboundary = leftboundary+999
	//		1728749 1461267 1150214 884892 349078 1699375
	// for regions of n loci
	
	// A selected alleles regions
	setCfgParam("Aregion", c(1727750:1728749, 1460268:1461267, 1149215:1150214));	
	
	// B selected alleles region
	setCfgParam("Bregion", c(883893:884892, 348079:349078, 1698376:1699375));
		
	// Migration matrix between populations
	setCfgParam("m", matrix(c(0.0, 0.1, 0.0, 0.0, 0.0,
									  0.1, 0.0, 0.0, 0.0, 0.0,
									  0.0, 0.0, 0.0, 0.0, 0.0,
									  0.0, 0.0, 0.0, 0.0, 0.1,
									  0.0, 0.0, 0.0, 0.1, 0.0), 
									  nrow = 5, byrow=T));
	
	
	// How often to check heterozygosity
	setCfgParam("checkHeRate", 100);
	
	// How many time points to check slope against for overall trend
	setCfgParam("HeCheckHistorySize", 20);
	
	// Whether to plot heterozygosity
	setCfgParam("plotHe", T);
	
	// Number of individuals to sample per subpopulation for vcf output
	setCfgParam("N_vcf", 10);
	
	// Input file path
	setCfgParam("inputFile", "/mnt/c/GitHub/SLiMTests/tests/coalBurnIn/new_chapt4.trees");
			
	// Model index
	setCfgParam("modelindex", 1);
	
	// Model identifier
	defineConstant("modelid", paste0(seed, "_", modelindex));
	
	// Output save path
	defineConstant("outputPath", paste0("output_", modelid, ".vcf"));
	
	initializeMutationRate(mu, ends = breaks);
	
	// m1 mutation type: neutral
	initializeMutationType("m1", 0.5, "f", 0.0);
	
	// m2 mutation type: beneficial in environment A, deleterious in environment B
	initializeMutationType("m2", 0.5, "f", s);
	m2.color = "cyan";
	
	// m3 mutation type: beneficial in environment B, deleterious in environment A
	initializeMutationType("m3", 0.5, "f", s);
	m3.color = "green";
	
	
	// g1 genomic element type: uses m1 for all mutations
	initializeGenomicElementType("g1", m1, 1.0);
	
	// uniform chromosome of length 100 kb with uniform recombination
	initializeGenomicElement(g1, 0, L-1);
	initializeRecombinationRate(r, breaks);	
}


function (void) setCfgParam(s$ name, ifls value) {
	// Automate defining constants for SLiMgui and slim command line
	if (!exists(name)) {
		defineConstant(name, value);
	}
}

function (numeric) updateRecentHeMatrix(ifls HeMatrix, ifls latestRow) {
	// Updates a recent heterozygosity matrix with the latest entry
	if (length(dim(HeMatrix)) != 2) {
		stop("HeMatrix must be a matrix.");
	}
	
	if (length(latestRow) != ncol(HeMatrix)) {
		stop("latestRow must have length equal to the number of columns in HeMatrix.");
	}
	
	n = nrow(HeMatrix);
	
	HeMatrix[1:(n-1),] = HeMatrix[0:(n-2),];
	HeMatrix[0,] = latestRow;
	return HeMatrix;
}

function (numeric) shift(fi x, [i$ n = 1]) {
	// Shifts a vector by n
	if (n == 0) {
		return x;
	}
	
	end = length(x) - 1;
		
	if (abs(n) > end) {
		if (isInteger(x)) {
			return integer(length(x));
		} else {
			return float(length(x));
		}
	}
	
	zero = isInteger(x) ? 0 else 0.0;

	// Handle lag case
	if ( n > 0 ) {
		x[n:end] = x[0:(end - n)];
		x[0:(n-1)] = zero;
		return x;
	}
	
	
	// Handle lead case, n < 0
	start = end + n;
	x[start:0] = x[end:(-n)];
	x[end:(start+1)] = zero;
	return x;
	
}

mutationEffect(m2) {
	// For any odd populations, don't change the selection coeff 
	if (match(subpop, sim.subpopulations) % 2 != 0) {
		return effect;
	}
	// Flip the selection coeff sign
	if (homozygous) {
		return 1.0 - mut.selectionCoeff;
	}
	
	return 1.0 + mut.mutationType.dominanceCoeff * -mut.selectionCoeff;
}

mutationEffect(m3) {
	// For any even populations, don't change the selection coeff 
	if (match(subpop, sim.subpopulations) % 2 == 0) {
		return effect;
	}
	// Flip the selection coeff sign
	if (homozygous) {
		return 1.0 - mut.selectionCoeff;
	}
	
	return 1.0 + mut.mutationType.dominanceCoeff * -mut.selectionCoeff;
}


// create subpopulations
1 early() {			
	// Setup simulation events
	community.rescheduleScriptBlock(s1, start = 1);
	community.rescheduleScriptBlock(s2, ticks = community.tick + 1000000); // Initialise these to in the far future
	community.rescheduleScriptBlock(s3, ticks = community.tick + 1000000); // they will be reset later
	
	// Setup plotting
	if (plotHe) {
		defineConstant("pdfPath", writeTempFile("plot_", ".png", ""));
		if (exists("slimgui"))
		{
			slimgui.openDocument(pdfPath);
		}
	}
}

// Read in population/mutation info
1 late() {
	sim.readFromPopulationFile(inputFile);
	
	// Set migration rates between population pairs
	for (i in seqAlong(sim.subpopulations)) {
		subpop = sim.subpopulations[i];		
		otherIndices = setDifference(seqAlong(sim.subpopulations), match(subpop, sim.subpopulations));
		others = sim.subpopulations[otherIndices];
		rates = c(m[i,])[otherIndices];
		subpop.setMigrationRates(others, rates);
	}
	
	// Set heterozygosity variables for equilibrium check
	defineGlobal("last_he", matrix(rep(1000000.0, size(sim.subpopulations) * HeCheckHistorySize), nrow = HeCheckHistorySize));
	sim.setValue("avg_he", NULL);

}

// Burn in
s1 late() {
	// Check that the populations are close to equilibrium
	// If we're at equilibrium in all subpops, continue with the test: check every 50 generations or so
	if (community.tick % checkHeRate == 0) {
		pop_avg = float(length(sim.subpopulations));
	
		// Get average genome-wide pairwise heterozygosity across 10 sampled individuals
		for (i in seqAlong(sim.subpopulations)) {
			subpop = sim.subpopulations[i];
			inds = subpop.sampleIndividuals(10);
			avg = 0;
				
			for (j in seqAlong(inds)) {
				avg = avg + (calcPairHeterozygosity(inds[j].haploidGenome1, inds[j].haploidGenome2) * 1 / length(inds));
			}
			
			pop_avg[i] = avg;
		}
							
		defineGlobal("last_he", updateRecentHeMatrix(last_he, pop_avg)); // Update heterozygosity history
		
		atEquil = T;

		// Check equilibrium - 
		// Lagged differences: average of the nth order slopes
		// Row = history sample, col = subpop He estimate, page = lagged difference order (e.g. n - (n-1), (n-1) - (n-2)...)
		diff = array(float(product(c(dim(last_he), HeCheckHistorySize))), c(dim(last_he), HeCheckHistorySize));
		diffSums = float(size(sim.subpopulations));
		for (i in 0:(HeCheckHistorySize-1)) {
			diff[,,i] = shift(last_he, n = i+1) - shift(last_he, n = i);
			diff[0:i,,i] = 0.0; // Ignore first i values, these are NA		
			diffSums = diffSums + colSums(matrix(diff[,,i], nrow(diff)));
		}
		
		// Average diffSums - exclude the 0s in diff
		// Each page in diff has HeCheckHistorySize - i non-zero rows, where i is the order of the difference  n - (n-i)
		// This is a triangular number or a sum from 1 to last_he - 1
		denominator = sum(1:(HeCheckHistorySize - 1));
		
		// Average the over all nonzero lagged differences
		avDiffs = abs(diffSums / denominator);
		if (sum(avDiffs) < 999.0 & plotHe) {
			catn(avDiffs); // print the average differences per population
		}
		
		// Check if we are not at equilibrium in any of the subpops
		if (any(avDiffs > eps)) {
			atEquil = F;
		}
		
		// Handle plotting in R
		if (plotHe) {
			avg_he = mean(pop_avg);
			he_history = c(sim.getValue("avg_he"), avg_he);
			sim.setValue("avg_he", he_history);

			rstr = paste(c('{',
			'x <- (1:' + size(he_history) + ' * ' + checkHeRate +')',
			'y <- c(' + paste(he_history, sep=", ") + ')',
			'png(file="' + pdfPath + '", width=4, height=4, units = "in", res = 72)',
			'par(mar=c(4, 4, 1.5, 1.5))',
			'plot(x=x, y=y, ylim=c(0, '+ (max(he_history) * 1.1) +'), type="l",',
			'xlab="Generation", ylab="Average heterozygosity", cex.axis=0.95,',
			'cex.lab=1.2, mgp=c(2.5, 0.7, 0), col="red", lwd=2,',
			'xaxp=c(0, ' + (community.tick + 100) + ', 4))',
			'box()',
			'dev.off()',
			'}'), sep="\n");

			scriptPath = writeTempFile("plot_", ".R", rstr);
			system("/usr/bin/Rscript", args=scriptPath);
			deleteFile(scriptPath);
		}
		
		// If we're at equilibrium we can reschedule the events to apply selection
		if (atEquil) {
			catn("Reached equilibrium at tick " + community.tick);
			community.deregisterScriptBlock(s1);
			community.rescheduleScriptBlock(s2, ticks = community.tick + 1);
			community.rescheduleScriptBlock(s3, ticks = community.tick + selTime);
		}
	}	
	
	if (community.tick >= 1000000) {
		stop("Failed to reach equilibrium heterozygosity...");
	}
}

// Apply selection to random mutations in selected regions
s2 late() {
	// Randomly sample mutations in the m2/m3 regions and turn them into m2/m3 mutations
	for (subpop in sim.subpopulations) {
		muts = subpop.haplosomes.mutations;
		isPopA = subpop.id % 2 == 0;	// Since p3/p5/p7 share an ecotype, we can distinguish from p4/p8 with mod 2
		regionType = isPopA ? Aregion else Bregion;
		
		// Iterate over regions
		for (i in seqLen(n_r)) {
			reg = regionType[(i*1000):(((i+1)*1000) - 1)]; // Select the correct region
			putIdx = match(reg, muts.position); 
			putIdx = putIdx[putIdx > -1];
			putative = muts[putIdx]; // Find any mutations in the region
		
			// Sample n_s mutations per subpop - unless there aren't enough mutations in the region,
			// then we choose the minimum
			n_muts = min(n_s, size(putative));
			adaptiveMut = sample(putative, n_muts);
		
			// Update mutation coefficients and type
			adaptiveMut.setMutationType(isPopA ? m2 else m3);
			adaptiveMut.setSelectionCoeff(s);
		}
	}
}

// Output at end of simulation
s3 late() {
	// Output VCF
	sampled = sim.subpopulations.sampleIndividuals(N_vcf);
	sampled.outputIndividualsToVCF(outputPath);
	
	sim.simulationFinished();
}
