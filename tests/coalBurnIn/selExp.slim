// set up a simple neutral simulation
initialize() {
	if (!exists("slimgui")) {
		defineConstant("seed", getSeed());
	}
	else {
		setSeed(asInteger(round(runif(1, 1, 2^62 - 1))));
		defineConstant("seed", getSeed());
		catn("Actual seed: " + asInteger(seed));
	}

	initializeSLiMModelType("WF");
	initializeTreeSeq(timeUnit = "generations");

	// Chromosome length
	setCfgParam("L", 9e6);

	// Mutation rates
	setCfgParam("mu", c(1e-8, 1e-9, 1e-8));
	
	setCfgParam("breaks", c(3000000, 6000000, 9000000-1));
	
	// Recombination rates
	setCfgParam("r", c(5e-8, 0.5e-8, 5e-8));
	
	// Selection coefficient
	setCfgParam("s", 0.05);
	
	// Population size
	setCfgParam("N", 5000);
	
	// Number of adaptive mutations
	setCfgParam("n_s", 1);
	
	// Equilibrium check epsilon
	setCfgParam("eps", 1e-6);
	
	// A selected alleles region
	setCfgParam("Aregion", c(1e5, 2e5));	
	
	// B selected alleles region
	setCfgParam("Bregion", c(5e5, 6e5));
	
	// Migration between A/B pairs
	setCfgParam("m", 0.1);
	
	// How often to check heterozygosity
	setCfgParam("checkHeRate", 100);
	
	// How many time points to check slope against for overall trend
	setCfgParam("HeCheckHistorySize", 20);
	
	// Input file path
	setCfgParam("inputFile", "/mnt/c/GitHub/SLiMTests/tests/coalBurnIn/test.trees");
			
	// Model index
	setCfgParam("modelindex", 1);
	
	// Model identifier
	defineConstant("modelid", paste0(seed, "_", modelindex));
	
	defineConstant("outputPath", paste0("output_", modelid, ".vcf"));
	
	initializeMutationRate(mu, ends = breaks);
	
	// m1 mutation type: neutral
	initializeMutationType("m1", 0.5, "f", 0.0);
	
	// m2 mutation type: beneficial in environment A, deleterious in environment B
	initializeMutationType("m2", 0.5, "f", s);
	m2.color = "red";
	
	// m3 mutation type: beneficial in environment B, deleterious in environment A
	initializeMutationType("m3", 0.5, "f", s);
	m3.color = "green";
	
	
	// g1 genomic element type: uses m1 for all mutations
	initializeGenomicElementType("g1", m1, 1.0);
	
	// uniform chromosome of length 100 kb with uniform recombination
	initializeGenomicElement(g1, 0, L-1);
	initializeRecombinationRate(r, breaks);	
}


function (void) setCfgParam(s$ name, ifls value) {
	// Automate defining constants for SLiMgui and slim command line
	if (!exists(name)) {
		defineConstant(name, value);
	}
}

function (numeric) updateRecentHeMatrix(ifls HeMatrix, ifls latestRow) {
	// Updates a recent heterozygosity matrix with the latest entry
	if (length(dim(HeMatrix)) != 2) {
		stop("HeMatrix must be a matrix.");
	}
	
	if (length(latestRow) != ncol(HeMatrix)) {
		stop("latestRow must have length equal to the number of columns in HeMatrix.");
	}
	
	n = nrow(HeMatrix);
	
	HeMatrix[1:(n-1),] = HeMatrix[0:(n-2),];
	HeMatrix[0,] = latestRow;
	return HeMatrix;
}

function (numeric) shift(fi x, [i$ n = 1]) {
	// Shifts a vector by n
	if (n == 0) {
		return x;
	}
	
	end = length(x) - 1;
		
	if (abs(n) > end) {
		if (isInteger(x)) {
			return integer(length(x));
		} else {
			return float(length(x));
		}
	}
	
	zero = isInteger(x) ? 0 else 0.0;

	// Handle lag case
	if ( n > 0 ) {
		x[n:end] = x[0:(end - n)];
		x[0:(n-1)] = zero;
		return x;
	}
	
	
	// Handle lead case, n < 0
	start = end + n;
	x[start:0] = x[end:(-n)];
	x[end:(start+1)] = zero;
	return x;
	
}

mutationEffect(m2) {
	// For any odd populations, don't change the selection coeff 
	if (subpop.id % 2 != 0) {
		return effect;
	}
	// Flip the selection coeff sign
	if (homozygous) {
		return 1.0 - mut.selectionCoeff;
	}
	
	return 1.0 + mut.mutationType.dominanceCoeff * -mut.selectionCoeff;
}

mutationEffect(m3) {
	// For any even populations, don't change the selection coeff 
	if (subpop.id % 2 == 0) {
		return effect;
	}
	// Flip the selection coeff sign
	if (homozygous) {
		return 1.0 - mut.selectionCoeff;
	}
	
	return 1.0 + mut.mutationType.dominanceCoeff * -mut.selectionCoeff;
}


// create subpopulations
1 early() {			
	// Setup simulation events
	community.rescheduleScriptBlock(s1, start = 1);
	community.rescheduleScriptBlock(s2, ticks = community.tick + 100 * N);
	community.rescheduleScriptBlock(s3, ticks = community.tick + 100 * N);
	
	// Setup plotting
	defineConstant("pdfPath", writeTempFile("plot_", ".png", ""));
	if (exists("slimgui"))
	{
		slimgui.openDocument(pdfPath);
	}

}

1 late() {
	// Read in population/mutation info
	sim.readFromPopulationFile(inputFile);
	
	// Handle migration
	for (i in seqAlong(sim.subpopulations)) {
		subpop = sim.subpopulations[i];
		
		if (i % 2 == 0) {
			subpop.setMigrationRates(sim.subpopulations[i+1], m);
		} else {
			subpop.setMigrationRates(sim.subpopulations[i-1], m);
		}
	}
	
	// Check for heterozygosity equilibrium
	defineGlobal("last_he", matrix(rep(1000000.0, size(sim.subpopulations) * HeCheckHistorySize), nrow = HeCheckHistorySize));
	sim.setValue("avg_he", NULL);

}

s1 late() {
	// Check that the populations are close to equilibrium
		
	// If we're at equilibrium in all subpops, continue with the test: check every 50 generations or so
	if (community.tick % checkHeRate == 0) {
	
		pop_avg = float(length(sim.subpopulations));
	
		for (i in seqAlong(sim.subpopulations)) {
			subpop = sim.subpopulations[i];
			inds = subpop.sampleIndividuals(10);
			avg = 0;
				
			for (j in seqAlong(inds)) {
				avg = avg + (calcPairHeterozygosity(inds[j].haploidGenome1, inds[j].haploidGenome2) * 1 / length(inds));
			}
			
			pop_avg[i] = avg;
		}
							
		defineGlobal("last_he", updateRecentHeMatrix(last_he, pop_avg));
		
		atEquil = T;

		// Check equilibrium - 
		// Lagged differences multi-order: average of the nth order slopes
		diff = array(float(product(c(dim(last_he), HeCheckHistorySize))), c(dim(last_he), HeCheckHistorySize));
		diffSums = float(size(sim.subpopulations));
		for (i in 0:(HeCheckHistorySize-1)) {
			diff[,,i] = abs(shift(last_he, n = i+1) - last_he);
			diff[0:i,,i] = 0.0; // Ignore first i values, these are NA
			
			diffSums = diffSums + colSums(matrix(diff[,,i], nrow(diff)));
		}
		
		// Turn diffSums to average - exclude the 0s (triangular number)
		tri = nrow(last_he) - 1;
		denominator = (tri * (tri + 1))/2;
		
		avDiffs = diffSums / denominator;
		catn(avDiffs);
		
		if (any(avDiffs > eps)) {
			atEquil = F;
		}
		
		// Handle plotting
			avg_he = mean(pop_avg);
			he_history = c(sim.getValue("avg_he"), avg_he);
			sim.setValue("avg_he", he_history);

			rstr = paste(c('{',
			'x <- (1:' + size(he_history) + ' * ' + checkHeRate +')',
			'y <- c(' + paste(he_history, sep=", ") + ')',
			'png(file="' + pdfPath + '", width=4, height=4, units = "in", res = 72)',
			'par(mar=c(4, 4, 1.5, 1.5))',
			'plot(x=x, y=y, ylim=c(0, '+ (max(he_history) * 1.1) +'), type="l",',
			'xlab="Generation", ylab="Average heterozygosity", cex.axis=0.95,',
			'cex.lab=1.2, mgp=c(2.5, 0.7, 0), col="red", lwd=2,',
			'xaxp=c(0, ' + (community.tick + 100) + ', 4))',
			'box()',
			'dev.off()',
			'}'), sep="\n");

			scriptPath = writeTempFile("plot_", ".R", rstr);
			system("/usr/bin/Rscript", args=scriptPath);
			deleteFile(scriptPath);

		if (atEquil) {
			catn("Reached equilibrium at tick " + community.tick);
			community.deregisterScriptBlock(s1);
			community.rescheduleScriptBlock(s2, ticks = community.tick + 1);
			community.rescheduleScriptBlock(s3, ticks = community.tick + 10000);
			
			if (exists("slimgui")) {
				slimgui.pauseExecution();
			}
			return;
		}
	}	
	
	if (community.tick >= 10 * N) {
		stop("Failed to reach equilibrium heterozygosity...");
	}
}

s2 late() {
//late() {
	// Randomly sample mutations in the m2/m3 regions and turn them into m2/m3 mutations
	for (subpop in sim.subpopulations) {
		muts = subpop.haplosomes.mutations;
		isPopA = subpop.id % 2 == 0;
		region = isPopA ? Aregion else Bregion;
		putative = muts[muts.position >= region[0] & muts.position <= region[1]];
		
		// Sample n_s mutations per subpop
		adaptiveMut = sample(putative, n_s);
		
		// Update mutation info
		adaptiveMut.setMutationType(isPopA ? m2 else m3);
		adaptiveMut.setSelectionCoeff(s);
	}
}

s3 late() {
	// Output VCF
	c(p1.genomes, p2.genomes).outputVCF(outputPath);
	
}
